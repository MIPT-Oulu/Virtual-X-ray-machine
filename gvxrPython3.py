# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.0
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError('Python 2.7 or later required')

# Import the low-level C/C++ module
if __package__ or '.' in __name__:
    from . import _gvxrPython3
else:
    import _gvxrPython3

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

# Copyright (c) 2019, Dr Franck P. Vidal (franck.p.vidal@fpvidal.net), http://www.fpvidal.net/
# All rights reserved.

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if name == "thisown":
        return self.this.own(value)
    if name == "this":
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if not static:
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if name == "thisown":
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


class SwigPyIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _gvxrPython3.delete_SwigPyIterator

    def value(self):
        return _gvxrPython3.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _gvxrPython3.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _gvxrPython3.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _gvxrPython3.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _gvxrPython3.SwigPyIterator_equal(self, x)

    def copy(self):
        return _gvxrPython3.SwigPyIterator_copy(self)

    def next(self):
        return _gvxrPython3.SwigPyIterator_next(self)

    def __next__(self):
        return _gvxrPython3.SwigPyIterator___next__(self)

    def previous(self):
        return _gvxrPython3.SwigPyIterator_previous(self)

    def advance(self, n):
        return _gvxrPython3.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _gvxrPython3.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _gvxrPython3.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _gvxrPython3.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _gvxrPython3.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _gvxrPython3.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _gvxrPython3.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self

# Register SwigPyIterator in _gvxrPython3:
_gvxrPython3.SwigPyIterator_swigregister(SwigPyIterator)

class Vectors(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def iterator(self):
        return _gvxrPython3.Vectors_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _gvxrPython3.Vectors___nonzero__(self)

    def __bool__(self):
        return _gvxrPython3.Vectors___bool__(self)

    def __len__(self):
        return _gvxrPython3.Vectors___len__(self)

    def __getslice__(self, i, j):
        return _gvxrPython3.Vectors___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _gvxrPython3.Vectors___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _gvxrPython3.Vectors___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _gvxrPython3.Vectors___delitem__(self, *args)

    def __getitem__(self, *args):
        return _gvxrPython3.Vectors___getitem__(self, *args)

    def __setitem__(self, *args):
        return _gvxrPython3.Vectors___setitem__(self, *args)

    def pop(self):
        return _gvxrPython3.Vectors_pop(self)

    def append(self, x):
        return _gvxrPython3.Vectors_append(self, x)

    def empty(self):
        return _gvxrPython3.Vectors_empty(self)

    def size(self):
        return _gvxrPython3.Vectors_size(self)

    def swap(self, v):
        return _gvxrPython3.Vectors_swap(self, v)

    def begin(self):
        return _gvxrPython3.Vectors_begin(self)

    def end(self):
        return _gvxrPython3.Vectors_end(self)

    def rbegin(self):
        return _gvxrPython3.Vectors_rbegin(self)

    def rend(self):
        return _gvxrPython3.Vectors_rend(self)

    def clear(self):
        return _gvxrPython3.Vectors_clear(self)

    def get_allocator(self):
        return _gvxrPython3.Vectors_get_allocator(self)

    def pop_back(self):
        return _gvxrPython3.Vectors_pop_back(self)

    def erase(self, *args):
        return _gvxrPython3.Vectors_erase(self, *args)

    def __init__(self, *args):
        _gvxrPython3.Vectors_swiginit(self, _gvxrPython3.new_Vectors(*args))

    def push_back(self, x):
        return _gvxrPython3.Vectors_push_back(self, x)

    def front(self):
        return _gvxrPython3.Vectors_front(self)

    def back(self):
        return _gvxrPython3.Vectors_back(self)

    def assign(self, n, x):
        return _gvxrPython3.Vectors_assign(self, n, x)

    def resize(self, *args):
        return _gvxrPython3.Vectors_resize(self, *args)

    def insert(self, *args):
        return _gvxrPython3.Vectors_insert(self, *args)

    def reserve(self, n):
        return _gvxrPython3.Vectors_reserve(self, n)

    def capacity(self):
        return _gvxrPython3.Vectors_capacity(self)
    __swig_destroy__ = _gvxrPython3.delete_Vectors

# Register Vectors in _gvxrPython3:
_gvxrPython3.Vectors_swigregister(Vectors)

class Vectori(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def iterator(self):
        return _gvxrPython3.Vectori_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _gvxrPython3.Vectori___nonzero__(self)

    def __bool__(self):
        return _gvxrPython3.Vectori___bool__(self)

    def __len__(self):
        return _gvxrPython3.Vectori___len__(self)

    def __getslice__(self, i, j):
        return _gvxrPython3.Vectori___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _gvxrPython3.Vectori___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _gvxrPython3.Vectori___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _gvxrPython3.Vectori___delitem__(self, *args)

    def __getitem__(self, *args):
        return _gvxrPython3.Vectori___getitem__(self, *args)

    def __setitem__(self, *args):
        return _gvxrPython3.Vectori___setitem__(self, *args)

    def pop(self):
        return _gvxrPython3.Vectori_pop(self)

    def append(self, x):
        return _gvxrPython3.Vectori_append(self, x)

    def empty(self):
        return _gvxrPython3.Vectori_empty(self)

    def size(self):
        return _gvxrPython3.Vectori_size(self)

    def swap(self, v):
        return _gvxrPython3.Vectori_swap(self, v)

    def begin(self):
        return _gvxrPython3.Vectori_begin(self)

    def end(self):
        return _gvxrPython3.Vectori_end(self)

    def rbegin(self):
        return _gvxrPython3.Vectori_rbegin(self)

    def rend(self):
        return _gvxrPython3.Vectori_rend(self)

    def clear(self):
        return _gvxrPython3.Vectori_clear(self)

    def get_allocator(self):
        return _gvxrPython3.Vectori_get_allocator(self)

    def pop_back(self):
        return _gvxrPython3.Vectori_pop_back(self)

    def erase(self, *args):
        return _gvxrPython3.Vectori_erase(self, *args)

    def __init__(self, *args):
        _gvxrPython3.Vectori_swiginit(self, _gvxrPython3.new_Vectori(*args))

    def push_back(self, x):
        return _gvxrPython3.Vectori_push_back(self, x)

    def front(self):
        return _gvxrPython3.Vectori_front(self)

    def back(self):
        return _gvxrPython3.Vectori_back(self)

    def assign(self, n, x):
        return _gvxrPython3.Vectori_assign(self, n, x)

    def resize(self, *args):
        return _gvxrPython3.Vectori_resize(self, *args)

    def insert(self, *args):
        return _gvxrPython3.Vectori_insert(self, *args)

    def reserve(self, n):
        return _gvxrPython3.Vectori_reserve(self, n)

    def capacity(self):
        return _gvxrPython3.Vectori_capacity(self)
    __swig_destroy__ = _gvxrPython3.delete_Vectori

# Register Vectori in _gvxrPython3:
_gvxrPython3.Vectori_swigregister(Vectori)

class Vectorui(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def iterator(self):
        return _gvxrPython3.Vectorui_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _gvxrPython3.Vectorui___nonzero__(self)

    def __bool__(self):
        return _gvxrPython3.Vectorui___bool__(self)

    def __len__(self):
        return _gvxrPython3.Vectorui___len__(self)

    def __getslice__(self, i, j):
        return _gvxrPython3.Vectorui___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _gvxrPython3.Vectorui___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _gvxrPython3.Vectorui___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _gvxrPython3.Vectorui___delitem__(self, *args)

    def __getitem__(self, *args):
        return _gvxrPython3.Vectorui___getitem__(self, *args)

    def __setitem__(self, *args):
        return _gvxrPython3.Vectorui___setitem__(self, *args)

    def pop(self):
        return _gvxrPython3.Vectorui_pop(self)

    def append(self, x):
        return _gvxrPython3.Vectorui_append(self, x)

    def empty(self):
        return _gvxrPython3.Vectorui_empty(self)

    def size(self):
        return _gvxrPython3.Vectorui_size(self)

    def swap(self, v):
        return _gvxrPython3.Vectorui_swap(self, v)

    def begin(self):
        return _gvxrPython3.Vectorui_begin(self)

    def end(self):
        return _gvxrPython3.Vectorui_end(self)

    def rbegin(self):
        return _gvxrPython3.Vectorui_rbegin(self)

    def rend(self):
        return _gvxrPython3.Vectorui_rend(self)

    def clear(self):
        return _gvxrPython3.Vectorui_clear(self)

    def get_allocator(self):
        return _gvxrPython3.Vectorui_get_allocator(self)

    def pop_back(self):
        return _gvxrPython3.Vectorui_pop_back(self)

    def erase(self, *args):
        return _gvxrPython3.Vectorui_erase(self, *args)

    def __init__(self, *args):
        _gvxrPython3.Vectorui_swiginit(self, _gvxrPython3.new_Vectorui(*args))

    def push_back(self, x):
        return _gvxrPython3.Vectorui_push_back(self, x)

    def front(self):
        return _gvxrPython3.Vectorui_front(self)

    def back(self):
        return _gvxrPython3.Vectorui_back(self)

    def assign(self, n, x):
        return _gvxrPython3.Vectorui_assign(self, n, x)

    def resize(self, *args):
        return _gvxrPython3.Vectorui_resize(self, *args)

    def insert(self, *args):
        return _gvxrPython3.Vectorui_insert(self, *args)

    def reserve(self, n):
        return _gvxrPython3.Vectorui_reserve(self, n)

    def capacity(self):
        return _gvxrPython3.Vectorui_capacity(self)
    __swig_destroy__ = _gvxrPython3.delete_Vectorui

# Register Vectorui in _gvxrPython3:
_gvxrPython3.Vectorui_swigregister(Vectorui)

class Vectorss(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def iterator(self):
        return _gvxrPython3.Vectorss_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _gvxrPython3.Vectorss___nonzero__(self)

    def __bool__(self):
        return _gvxrPython3.Vectorss___bool__(self)

    def __len__(self):
        return _gvxrPython3.Vectorss___len__(self)

    def __getslice__(self, i, j):
        return _gvxrPython3.Vectorss___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _gvxrPython3.Vectorss___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _gvxrPython3.Vectorss___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _gvxrPython3.Vectorss___delitem__(self, *args)

    def __getitem__(self, *args):
        return _gvxrPython3.Vectorss___getitem__(self, *args)

    def __setitem__(self, *args):
        return _gvxrPython3.Vectorss___setitem__(self, *args)

    def pop(self):
        return _gvxrPython3.Vectorss_pop(self)

    def append(self, x):
        return _gvxrPython3.Vectorss_append(self, x)

    def empty(self):
        return _gvxrPython3.Vectorss_empty(self)

    def size(self):
        return _gvxrPython3.Vectorss_size(self)

    def swap(self, v):
        return _gvxrPython3.Vectorss_swap(self, v)

    def begin(self):
        return _gvxrPython3.Vectorss_begin(self)

    def end(self):
        return _gvxrPython3.Vectorss_end(self)

    def rbegin(self):
        return _gvxrPython3.Vectorss_rbegin(self)

    def rend(self):
        return _gvxrPython3.Vectorss_rend(self)

    def clear(self):
        return _gvxrPython3.Vectorss_clear(self)

    def get_allocator(self):
        return _gvxrPython3.Vectorss_get_allocator(self)

    def pop_back(self):
        return _gvxrPython3.Vectorss_pop_back(self)

    def erase(self, *args):
        return _gvxrPython3.Vectorss_erase(self, *args)

    def __init__(self, *args):
        _gvxrPython3.Vectorss_swiginit(self, _gvxrPython3.new_Vectorss(*args))

    def push_back(self, x):
        return _gvxrPython3.Vectorss_push_back(self, x)

    def front(self):
        return _gvxrPython3.Vectorss_front(self)

    def back(self):
        return _gvxrPython3.Vectorss_back(self)

    def assign(self, n, x):
        return _gvxrPython3.Vectorss_assign(self, n, x)

    def resize(self, *args):
        return _gvxrPython3.Vectorss_resize(self, *args)

    def insert(self, *args):
        return _gvxrPython3.Vectorss_insert(self, *args)

    def reserve(self, n):
        return _gvxrPython3.Vectorss_reserve(self, n)

    def capacity(self):
        return _gvxrPython3.Vectorss_capacity(self)
    __swig_destroy__ = _gvxrPython3.delete_Vectorss

# Register Vectorss in _gvxrPython3:
_gvxrPython3.Vectorss_swigregister(Vectorss)

class Vectorf(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def iterator(self):
        return _gvxrPython3.Vectorf_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _gvxrPython3.Vectorf___nonzero__(self)

    def __bool__(self):
        return _gvxrPython3.Vectorf___bool__(self)

    def __len__(self):
        return _gvxrPython3.Vectorf___len__(self)

    def __getslice__(self, i, j):
        return _gvxrPython3.Vectorf___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _gvxrPython3.Vectorf___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _gvxrPython3.Vectorf___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _gvxrPython3.Vectorf___delitem__(self, *args)

    def __getitem__(self, *args):
        return _gvxrPython3.Vectorf___getitem__(self, *args)

    def __setitem__(self, *args):
        return _gvxrPython3.Vectorf___setitem__(self, *args)

    def pop(self):
        return _gvxrPython3.Vectorf_pop(self)

    def append(self, x):
        return _gvxrPython3.Vectorf_append(self, x)

    def empty(self):
        return _gvxrPython3.Vectorf_empty(self)

    def size(self):
        return _gvxrPython3.Vectorf_size(self)

    def swap(self, v):
        return _gvxrPython3.Vectorf_swap(self, v)

    def begin(self):
        return _gvxrPython3.Vectorf_begin(self)

    def end(self):
        return _gvxrPython3.Vectorf_end(self)

    def rbegin(self):
        return _gvxrPython3.Vectorf_rbegin(self)

    def rend(self):
        return _gvxrPython3.Vectorf_rend(self)

    def clear(self):
        return _gvxrPython3.Vectorf_clear(self)

    def get_allocator(self):
        return _gvxrPython3.Vectorf_get_allocator(self)

    def pop_back(self):
        return _gvxrPython3.Vectorf_pop_back(self)

    def erase(self, *args):
        return _gvxrPython3.Vectorf_erase(self, *args)

    def __init__(self, *args):
        _gvxrPython3.Vectorf_swiginit(self, _gvxrPython3.new_Vectorf(*args))

    def push_back(self, x):
        return _gvxrPython3.Vectorf_push_back(self, x)

    def front(self):
        return _gvxrPython3.Vectorf_front(self)

    def back(self):
        return _gvxrPython3.Vectorf_back(self)

    def assign(self, n, x):
        return _gvxrPython3.Vectorf_assign(self, n, x)

    def resize(self, *args):
        return _gvxrPython3.Vectorf_resize(self, *args)

    def insert(self, *args):
        return _gvxrPython3.Vectorf_insert(self, *args)

    def reserve(self, n):
        return _gvxrPython3.Vectorf_reserve(self, n)

    def capacity(self):
        return _gvxrPython3.Vectorf_capacity(self)
    __swig_destroy__ = _gvxrPython3.delete_Vectorf

# Register Vectorf in _gvxrPython3:
_gvxrPython3.Vectorf_swigregister(Vectorf)

class Vectord(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def iterator(self):
        return _gvxrPython3.Vectord_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _gvxrPython3.Vectord___nonzero__(self)

    def __bool__(self):
        return _gvxrPython3.Vectord___bool__(self)

    def __len__(self):
        return _gvxrPython3.Vectord___len__(self)

    def __getslice__(self, i, j):
        return _gvxrPython3.Vectord___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _gvxrPython3.Vectord___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _gvxrPython3.Vectord___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _gvxrPython3.Vectord___delitem__(self, *args)

    def __getitem__(self, *args):
        return _gvxrPython3.Vectord___getitem__(self, *args)

    def __setitem__(self, *args):
        return _gvxrPython3.Vectord___setitem__(self, *args)

    def pop(self):
        return _gvxrPython3.Vectord_pop(self)

    def append(self, x):
        return _gvxrPython3.Vectord_append(self, x)

    def empty(self):
        return _gvxrPython3.Vectord_empty(self)

    def size(self):
        return _gvxrPython3.Vectord_size(self)

    def swap(self, v):
        return _gvxrPython3.Vectord_swap(self, v)

    def begin(self):
        return _gvxrPython3.Vectord_begin(self)

    def end(self):
        return _gvxrPython3.Vectord_end(self)

    def rbegin(self):
        return _gvxrPython3.Vectord_rbegin(self)

    def rend(self):
        return _gvxrPython3.Vectord_rend(self)

    def clear(self):
        return _gvxrPython3.Vectord_clear(self)

    def get_allocator(self):
        return _gvxrPython3.Vectord_get_allocator(self)

    def pop_back(self):
        return _gvxrPython3.Vectord_pop_back(self)

    def erase(self, *args):
        return _gvxrPython3.Vectord_erase(self, *args)

    def __init__(self, *args):
        _gvxrPython3.Vectord_swiginit(self, _gvxrPython3.new_Vectord(*args))

    def push_back(self, x):
        return _gvxrPython3.Vectord_push_back(self, x)

    def front(self):
        return _gvxrPython3.Vectord_front(self)

    def back(self):
        return _gvxrPython3.Vectord_back(self)

    def assign(self, n, x):
        return _gvxrPython3.Vectord_assign(self, n, x)

    def resize(self, *args):
        return _gvxrPython3.Vectord_resize(self, *args)

    def insert(self, *args):
        return _gvxrPython3.Vectord_insert(self, *args)

    def reserve(self, n):
        return _gvxrPython3.Vectord_reserve(self, n)

    def capacity(self):
        return _gvxrPython3.Vectord_capacity(self)
    __swig_destroy__ = _gvxrPython3.delete_Vectord

# Register Vectord in _gvxrPython3:
_gvxrPython3.Vectord_swigregister(Vectord)

class Vectorff(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def iterator(self):
        return _gvxrPython3.Vectorff_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _gvxrPython3.Vectorff___nonzero__(self)

    def __bool__(self):
        return _gvxrPython3.Vectorff___bool__(self)

    def __len__(self):
        return _gvxrPython3.Vectorff___len__(self)

    def __getslice__(self, i, j):
        return _gvxrPython3.Vectorff___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _gvxrPython3.Vectorff___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _gvxrPython3.Vectorff___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _gvxrPython3.Vectorff___delitem__(self, *args)

    def __getitem__(self, *args):
        return _gvxrPython3.Vectorff___getitem__(self, *args)

    def __setitem__(self, *args):
        return _gvxrPython3.Vectorff___setitem__(self, *args)

    def pop(self):
        return _gvxrPython3.Vectorff_pop(self)

    def append(self, x):
        return _gvxrPython3.Vectorff_append(self, x)

    def empty(self):
        return _gvxrPython3.Vectorff_empty(self)

    def size(self):
        return _gvxrPython3.Vectorff_size(self)

    def swap(self, v):
        return _gvxrPython3.Vectorff_swap(self, v)

    def begin(self):
        return _gvxrPython3.Vectorff_begin(self)

    def end(self):
        return _gvxrPython3.Vectorff_end(self)

    def rbegin(self):
        return _gvxrPython3.Vectorff_rbegin(self)

    def rend(self):
        return _gvxrPython3.Vectorff_rend(self)

    def clear(self):
        return _gvxrPython3.Vectorff_clear(self)

    def get_allocator(self):
        return _gvxrPython3.Vectorff_get_allocator(self)

    def pop_back(self):
        return _gvxrPython3.Vectorff_pop_back(self)

    def erase(self, *args):
        return _gvxrPython3.Vectorff_erase(self, *args)

    def __init__(self, *args):
        _gvxrPython3.Vectorff_swiginit(self, _gvxrPython3.new_Vectorff(*args))

    def push_back(self, x):
        return _gvxrPython3.Vectorff_push_back(self, x)

    def front(self):
        return _gvxrPython3.Vectorff_front(self)

    def back(self):
        return _gvxrPython3.Vectorff_back(self)

    def assign(self, n, x):
        return _gvxrPython3.Vectorff_assign(self, n, x)

    def resize(self, *args):
        return _gvxrPython3.Vectorff_resize(self, *args)

    def insert(self, *args):
        return _gvxrPython3.Vectorff_insert(self, *args)

    def reserve(self, n):
        return _gvxrPython3.Vectorff_reserve(self, n)

    def capacity(self):
        return _gvxrPython3.Vectorff_capacity(self)
    __swig_destroy__ = _gvxrPython3.delete_Vectorff

# Register Vectorff in _gvxrPython3:
_gvxrPython3.Vectorff_swigregister(Vectorff)

class Vectordd(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def iterator(self):
        return _gvxrPython3.Vectordd_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _gvxrPython3.Vectordd___nonzero__(self)

    def __bool__(self):
        return _gvxrPython3.Vectordd___bool__(self)

    def __len__(self):
        return _gvxrPython3.Vectordd___len__(self)

    def __getslice__(self, i, j):
        return _gvxrPython3.Vectordd___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _gvxrPython3.Vectordd___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _gvxrPython3.Vectordd___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _gvxrPython3.Vectordd___delitem__(self, *args)

    def __getitem__(self, *args):
        return _gvxrPython3.Vectordd___getitem__(self, *args)

    def __setitem__(self, *args):
        return _gvxrPython3.Vectordd___setitem__(self, *args)

    def pop(self):
        return _gvxrPython3.Vectordd_pop(self)

    def append(self, x):
        return _gvxrPython3.Vectordd_append(self, x)

    def empty(self):
        return _gvxrPython3.Vectordd_empty(self)

    def size(self):
        return _gvxrPython3.Vectordd_size(self)

    def swap(self, v):
        return _gvxrPython3.Vectordd_swap(self, v)

    def begin(self):
        return _gvxrPython3.Vectordd_begin(self)

    def end(self):
        return _gvxrPython3.Vectordd_end(self)

    def rbegin(self):
        return _gvxrPython3.Vectordd_rbegin(self)

    def rend(self):
        return _gvxrPython3.Vectordd_rend(self)

    def clear(self):
        return _gvxrPython3.Vectordd_clear(self)

    def get_allocator(self):
        return _gvxrPython3.Vectordd_get_allocator(self)

    def pop_back(self):
        return _gvxrPython3.Vectordd_pop_back(self)

    def erase(self, *args):
        return _gvxrPython3.Vectordd_erase(self, *args)

    def __init__(self, *args):
        _gvxrPython3.Vectordd_swiginit(self, _gvxrPython3.new_Vectordd(*args))

    def push_back(self, x):
        return _gvxrPython3.Vectordd_push_back(self, x)

    def front(self):
        return _gvxrPython3.Vectordd_front(self)

    def back(self):
        return _gvxrPython3.Vectordd_back(self)

    def assign(self, n, x):
        return _gvxrPython3.Vectordd_assign(self, n, x)

    def resize(self, *args):
        return _gvxrPython3.Vectordd_resize(self, *args)

    def insert(self, *args):
        return _gvxrPython3.Vectordd_insert(self, *args)

    def reserve(self, n):
        return _gvxrPython3.Vectordd_reserve(self, n)

    def capacity(self):
        return _gvxrPython3.Vectordd_capacity(self)
    __swig_destroy__ = _gvxrPython3.delete_Vectordd

# Register Vectordd in _gvxrPython3:
_gvxrPython3.Vectordd_swigregister(Vectordd)


def getMajorVersionOfCoreGVXR():
    r"""


    Accessor on the major version of the core gVirtualXRay library (gvxr). This
    number is changed when incompatible API changes have been made.  

    Returns
    -------
    the major version number  

    """
    return _gvxrPython3.getMajorVersionOfCoreGVXR()

def getMinorVersionOfCoreGVXR():
    r"""


    Accessor on the minor version of the core gVirtualXRay library (gvxr). This
    number is changed when new functionalities have been added in a backwards-
    compatible manner.  

    Returns
    -------
    the minor version number  

    """
    return _gvxrPython3.getMinorVersionOfCoreGVXR()

def getPatchVersionOfCoreGVXR():
    r"""


    Accessor on the minor version of the core gVirtualXRay library (gvxr). This
    number is changed when bug fixes have been added in a backwards-compatible
    manner.  

    Returns
    -------
    the patch version number  

    """
    return _gvxrPython3.getPatchVersionOfCoreGVXR()

def getVersionOfCoreGVXR():
    r"""


    Accessor on the full string version of the core gVirtualXRay library (gvxr).  

    Returns
    -------
    the full version number  

    """
    return _gvxrPython3.getVersionOfCoreGVXR()

def getMajorVersionOfSimpleGVXR():
    r"""


    Accessor on the major version of SimpleGVXR. This number is changed when
    incompatible API changes have been made.  

    Returns
    -------
    the major version number  

    """
    return _gvxrPython3.getMajorVersionOfSimpleGVXR()

def getMinorVersionOfSimpleGVXR():
    r"""


    Accessor on the minor version of SimpleGVXR. This number is changed when new
    functionalities have been added in a backwards-compatible manner.  

    Returns
    -------
    the minor version number  

    """
    return _gvxrPython3.getMinorVersionOfSimpleGVXR()

def getPatchVersionOfSimpleGVXR():
    r"""


    Accessor on the minor version of SimpleGVXR. This number is changed when bug
    fixes have been added in a backwards-compatible manner.  

    Returns
    -------
    the patch version number  

    """
    return _gvxrPython3.getPatchVersionOfSimpleGVXR()

def getVersionOfSimpleGVXR():
    r"""


    Accessor on the full string version of SimpleGVXR.  

    Returns
    -------
    the full version number  

    """
    return _gvxrPython3.getVersionOfSimpleGVXR()

def orthographic(left, right, bottom, top, zNear, zFar):
    r"""


    Replace the projection matrix by a orthographic projection matrix. It behaves as
    the old glOrtho function.  

    Parameters
    ----------
    * `left` :  
        Specify the coordinates for the left vertical clipping plane  
    * `right` :  
        Specify the coordinates for the right vertical clipping plane  
    * `bottom` :  
        Specify the coordinates for the bottom horizontal clipping plane  
    * `top` :  
        Specify the coordinates for the top horizontal clipping plane  
    * `zNear` :  
        Specify the distances to the near clipping plane. The value must be positive  
    * `zFar` :  
        Specify the distances to the far clipping plane. The value must be positive  

    """
    return _gvxrPython3.orthographic(left, right, bottom, top, zNear, zFar)

def perspective(fovy, aspect, zNear, zFar):
    r"""


    Replace the projection matrix by a perspective projection matrix. It behaves as
    the old gluPerspective function.  

    Parameters
    ----------
    * `fovy` :  
        specifies the field of view angle, in degrees, in the y-direction.  
    * `aspect` :  
        Specifies the aspect ratio that determines the field of view in the x
        direction. The aspect ratio is the ratio of x (width) to y (height).  
    * `zNear` :  
        Specifies the distance from the viewer to the near clipping plane (always
        positive)  
    * `zFar` :  
        Specifies the distance from the viewer to the far clipping plane (always
        positive).  

    """
    return _gvxrPython3.perspective(fovy, aspect, zNear, zFar)

def lookAt(eyeX, eyeY, eyeZ, lookAtX, lookAtY, lookAtZ, upX, upY, upZ):
    r"""


    Replace the modelling-viewing matrix by a viewing transformation matrix. It
    behaves as the old gluLookAt function.  

    Parameters
    ----------
    * `eyeX` :  
        Specifies the position of the eye point along the X-axis  
    * `eyeY` :  
        Specifies the position of the eye point along the Y-axis  
    * `eyeZ` :  
        Specifies the position of the eye point along the Z-axis  
    * `lookAtX` :  
        Specifies the position of the reference point along the X-axis  
    * `lookAtY` :  
        Specifies the position of the reference point along the Y-axis  
    * `lookAtZ` :  
        Specifies the position of the reference point along the Z-axis  
    * `upX` :  
        Specifies the direction of the up vector along the X-axis  
    * `upY` :  
        Specifies the direction of the up vector along the Y-axis  
    * `upZ` :  
        Specifies the direction of the up vector along the Z-axis  

    """
    return _gvxrPython3.lookAt(eyeX, eyeY, eyeZ, lookAtX, lookAtY, lookAtZ, upX, upY, upZ)

def pushModelViewMatrix():
    r"""


    Add the current matrix to the model/view matrix stack. It behaves as the
    combination of the old glMatrixMode(GL_MODELVIEW);glPushMatrix() functions.  

    """
    return _gvxrPython3.pushModelViewMatrix()

def popModelViewMatrix():
    r"""


    Restore the matrix from the model/view matrix stack, and remove the last matrix
    of the stack. glMatrixMode(GL_MODELVIEW);glPopMatrix() functions.  

    """
    return _gvxrPython3.popModelViewMatrix()

def rotateModelView(anAngle, x, y, z):
    r"""


    Restore the matrix from the model/view matrix stack, and remove the last matrix
    of the stack. glMatrixMode(GL_MODELVIEW);glRotate() functions.  

    Parameters
    ----------
    * `anAngle` :  
        the angle of rotation in degrees  
    * `x` :  
        the coordinate of the rotation axis along the X-axis  
    * `y` :  
        the coordinate of the rotation axis along the Y-axis  
    * `z` :  
        the coordinate of the rotation axis along the Z-axis  

    """
    return _gvxrPython3.rotateModelView(anAngle, x, y, z)

def autoCreateOpenGLContext(aFlag=True):
    r"""


    Create an OpenGL context automatically.  

    Parameters
    ----------
    * `aFlag` :  
        true to create the OpenGL context automatically, false otherwise (default
        value: true)  

    """
    return _gvxrPython3.autoCreateOpenGLContext(aFlag)

def setSourcePosition(x, y, z, aUnitOfLength):
    r"""


    Set the position of the X-ray source.  

    Parameters
    ----------
    * `x` :  
        the position along the X-axis  
    * `y` :  
        the position along the Y-axis  
    * `z` :  
        the position along the Z-axis  
    * `aUnitOfLength` :  
        the unit of length corresponding to the x, y and z parameters. Acceptable
        values are: "um", "micrometre", "micrometer", "mm", "millimetre",
        "millimeter", "cm", "centimetre", "centimeter", "dm",
        "decimetre", "decimeter", "m", "metre", "meter", "dam",
        "decametre", "decameter", "hm", "hectometre", "hectometer",
        "km", "kilometre", "kilometer"  

    """
    return _gvxrPython3.setSourcePosition(x, y, z, aUnitOfLength)

def getSourcePosition(aUnitOfLength):
    r"""


    Accessor on the position of the X-ray source.  

    Parameters
    ----------
    * `aUnitOfLength` :  
        the unit of length corresponding to the returned value. Acceptable values
        are: "um", "micrometre", "micrometer", "mm", "millimetre",
        "millimeter", "cm", "centimetre", "centimeter", "dm",
        "decimetre", "decimeter", "m", "metre", "meter", "dam",
        "decametre", "decameter", "hm", "hectometre", "hectometer",
        "km", "kilometre", "kilometer"  

    Returns
    -------
    the source position in a given unit of length  

    """
    return _gvxrPython3.getSourcePosition(aUnitOfLength)

def setDetectorPosition(x, y, z, aUnitOfLength):
    r"""


    Set the position of the X-ray detector.  

    Parameters
    ----------
    * `x` :  
        the position along the X-axis  
    * `y` :  
        the position along the Y-axis  
    * `z` :  
        the position along the Z-axis  
    * `aUnitOfLength` :  
        the unit of length corresponding to the x, y and z parameters. Acceptable
        values are: "um", "micrometre", "micrometer", "mm", "millimetre",
        "millimeter", "cm", "centimetre", "centimeter", "dm",
        "decimetre", "decimeter", "m", "metre", "meter", "dam",
        "decametre", "decameter", "hm", "hectometre", "hectometer",
        "km", "kilometre", "kilometer"  

    """
    return _gvxrPython3.setDetectorPosition(x, y, z, aUnitOfLength)

def getDetectorPosition(aUnitOfLength):
    r"""


    Accessor on the position of the X-ray detector.  

    Parameters
    ----------
    * `aUnitOfLength` :  
        the unit of length corresponding to the returned value. Acceptable values
        are: "um", "micrometre", "micrometer", "mm", "millimetre",
        "millimeter", "cm", "centimetre", "centimeter", "dm",
        "decimetre", "decimeter", "m", "metre", "meter", "dam",
        "decametre", "decameter", "hm", "hectometre", "hectometer",
        "km", "kilometre", "kilometer"  

    Returns
    -------
    the source position in a given unit of length  

    """
    return _gvxrPython3.getDetectorPosition(aUnitOfLength)

def setDetectorUpVector(x, y, z):
    r"""


    Set the up-vector defining the orientation of the X-ray detector.  

    Parameters
    ----------
    * `x` :  
        the component of the vector along the X-axis  
    * `y` :  
        the component of the vector along the Y-axis  
    * `z` :  
        the component of the vector along the Z-axis  

    """
    return _gvxrPython3.setDetectorUpVector(x, y, z)

def getDetectorUpVector():
    r"""


    Accessor on the up-vector defining the orientation of the X-ray detector.  

    Returns
    -------
    the up-vector  

    """
    return _gvxrPython3.getDetectorUpVector()

def getDetectorRightVector():
    r"""


    Accessor on the right-vector defining the orientation of the X-ray detector.  

    Returns
    -------
    the right-vector  

    """
    return _gvxrPython3.getDetectorRightVector()

def setDetectorNumberOfPixels(aWidth, aHeight):
    r"""


    Set the number of pixels of the X-ray detector.  

    Parameters
    ----------
    * `aWidth` :  
        the number of pixels along the X-axis  
    * `aHeight` :  
        the number of pixels along the Y-axis  

    """
    return _gvxrPython3.setDetectorNumberOfPixels(aWidth, aHeight)

def getDetectorNumberOfPixels():
    r"""


    Accessor on the number of pixels of the X-ray detector.  

    Returns
    -------
    the size of the detector in number of pixels  

    """
    return _gvxrPython3.getDetectorNumberOfPixels()

def setDetectorPixelSize(aWidth, aHeight, aUnitOfLength):
    r"""


    Set the pixel size.  

    Parameters
    ----------
    * `aWidth` :  
        the pixel size along the X-axis  
    * `aHeight` :  
        the pixel size along the Y-axis  
    * `aUnitOfLength` :  
        the unit of length corresponding to the aWidth and aHeight parameters.
        Acceptable values are: "um", "micrometre", "micrometer", "mm",
        "millimetre", "millimeter", "cm", "centimetre", "centimeter",
        "dm", "decimetre", "decimeter", "m", "metre", "meter", "dam",
        "decametre", "decameter", "hm", "hectometre", "hectometer",
        "km", "kilometre", "kilometer"  

    """
    return _gvxrPython3.setDetectorPixelSize(aWidth, aHeight, aUnitOfLength)

def getDetectorSize(aUnitOfLength):
    r"""


    Accessor on the size of the X-ray detector.  

    Parameters
    ----------
    * `aUnitOfLength` :  
        the unit of length corresponding to the returned value. Acceptable values
        are: "um", "micrometre", "micrometer", "mm", "millimetre",
        "millimeter", "cm", "centimetre", "centimeter", "dm",
        "decimetre", "decimeter", "m", "metre", "meter", "dam",
        "decametre", "decameter", "hm", "hectometre", "hectometer",
        "km", "kilometre", "kilometer"  

    Returns
    -------
    the size in a given unit of length  

    """
    return _gvxrPython3.getDetectorSize(aUnitOfLength)

def loadMeshFile(aLabel, aFileName, aUnitOfLength):
    r"""


    Load a polygon mesh from a file, set its label in the scenegraph (i.e.
    identifier) and add it to the X-ray renderer.  

    Parameters
    ----------
    * `aLabel` :  
        the label in the scenegraph  
    * `aFileName` :  
        the file where the polygon mesh data is stored  
    * `aUnitOfLength` :  
        the unit of length corresponding to the data stored in the file. Acceptable
        values are: "um", "micrometre", "micrometer", "mm", "millimetre",
        "millimeter", "cm", "centimetre", "centimeter", "dm",
        "decimetre", "decimeter", "m", "metre", "meter", "dam",
        "decametre", "decameter", "hm", "hectometre", "hectometer",
        "km", "kilometre", "kilometer"  

    """
    return _gvxrPython3.loadMeshFile(aLabel, aFileName, aUnitOfLength)

def loadSceneGraph(aFileName, aUnitOfLength):
    r"""


    Load a scenegraph from a file and add its polygon meshes to the X-ray renderer.  

    Parameters
    ----------
    * `aFileName` :  
        the file where the polygon mesh data is stored  
    * `aUnitOfLength` :  
        the unit of length corresponding to the data stored in the file. Acceptable
        values are: "um", "micrometre", "micrometer", "mm", "millimetre",
        "millimeter", "cm", "centimetre", "centimeter", "dm",
        "decimetre", "decimeter", "m", "metre", "meter", "dam",
        "decametre", "decameter", "hm", "hectometre", "hectometer",
        "km", "kilometre", "kilometer"  

    """
    return _gvxrPython3.loadSceneGraph(aFileName, aUnitOfLength)

def emptyMesh(*args):
    r"""


    Create an empty polygon mesh and set its label in the scenegraph (i.e.
    identifier). Note that it is not added to the X-ray renderer.  

    Parameters
    ----------
    * `aLabel` :  
        the label in the scenegraph  
    * `aParent` :  
        the parent of the node in the scenegraph (default: "root")  

    """
    return _gvxrPython3.emptyMesh(*args)

def makeCube(*args):
    r"""


    Create a cube and set its label in the scenegraph (i.e. identifier). Note that
    it is not added to the X-ray renderer.  

    Parameters
    ----------
    * `aLabel` :  
        the label in the scenegraph  
    * `aLength` :  
        the size of an edge of the cube  
    * `aUnitOfLength` :  
        the unit of length corresponding to aLength. Acceptable values are: "um",
        "micrometre", "micrometer", "mm", "millimetre", "millimeter",
        "cm", "centimetre", "centimeter", "dm", "decimetre",
        "decimeter", "m", "metre", "meter", "dam", "decametre",
        "decameter", "hm", "hectometre", "hectometer", "km",
        "kilometre", "kilometer" (default value: "cm")  
    * `aParent` :  
        the parent of the node in the scenegraph (default: "root")  

    """
    return _gvxrPython3.makeCube(*args)

def makeCylinder(*args):
    r"""


    Create a cylinder and set its label in the scenegraph (i.e. identifier). Note
    that it is not added to the X-ray renderer.  

    Parameters
    ----------
    * `aLabel` :  
        the label in the scenegraph  
    * `aNumberOfSectors` :  
        the number of sector defining the mesh  
    * `aHeight` :  
        the height of the cylinder  
    * `aRadius` :  
        the radius of the cylinder  
    * `aUnitOfLength` :  
        the unit of length corresponding to aHeight and aRadius. Acceptable values
        are: "um", "micrometre", "micrometer", "mm", "millimetre",
        "millimeter", "cm", "centimetre", "centimeter", "dm",
        "decimetre", "decimeter", "m", "metre", "meter", "dam",
        "decametre", "decameter", "hm", "hectometre", "hectometer",
        "km", "kilometre", "kilometer" (default value: "cm")  
    * `aParent` :  
        the parent of the node in the scenegraph (default: "root")  

    """
    return _gvxrPython3.makeCylinder(*args)

def makeIsoSurface(*args):
    r"""


    Create an iso-surface from a 3D image and set its label in the scenegraph (i.e.
    identifier). Note that it is not added to the X-ray renderer.  

    Parameters
    ----------
    * `aLabel` :  
        the label in the scenegraph  
    * `anIsoValue` :  
        the iso-value  
    * `aVoxelDataSet` :  
        the voxel dataset  
    * `aWidth` :  
        the number of voxel along the X-axis  
    * `aHeight` :  
        the number of voxel along the Y-axis  
    * `aDepth` :  
        the number of voxel along the Z-axis  
    * `aSpacingX` :  
        the space between the centre of two successive voxels along the X-axis  
    * `aSpacingY` :  
        the space between the centre of two successive voxels along the Y-axis  
    * `aSpacingZ` :  
        the space between the centre of two successive voxels along the Z-axis  
    * `aUnitOfLength` :  
        the unit of length corresponding to aSpacingX, aSpacingY and aSpacingZ.
        Acceptable values are: "um", "micrometre", "micrometer", "mm",
        "millimetre", "millimeter", "cm", "centimetre", "centimeter",
        "dm", "decimetre", "decimeter", "m", "metre", "meter", "dam",
        "decametre", "decameter", "hm", "hectometre", "hectometer",
        "km", "kilometre", "kilometer" (default value: "cm")  
    * `aParent` :  
        the parent of the node in the scenegraph (default: "root")  

    """
    return _gvxrPython3.makeIsoSurface(*args)

def makeTriangularMesh(*args):
    return _gvxrPython3.makeTriangularMesh(*args)

def addMesh(aDestination, aSource):
    r"""


    Add a polygon mesh (aSource) to another one (aDestination). It corresponds to
    the operation as follows: aDestination += aSource. Both aSource and aDestination
    have to already exist in the scenegraph.  

    Parameters
    ----------
    * `aDestination` :  
        the polygon mesh that is going to be modified  
    * `aSource` :  
        the polygon mesh that is going to be added to aDestination  

    """
    return _gvxrPython3.addMesh(aDestination, aSource)

def subtractMesh(aDestination, aSource):
    r"""


    Subtract a polygon mesh (aSource) from another one (aDestination). It
    corresponds to the operation as follows: aDestination -= aSource. Both aSource
    and aDestination have to already exist in the scenegraph.  

    Parameters
    ----------
    * `aDestination` :  
        the polygon mesh that is going to be modified  
    * `aSource` :  
        the polygon mesh that is going to be subtracted from aDestination  

    """
    return _gvxrPython3.subtractMesh(aDestination, aSource)

def getNumberOfChildren(aLabel):
    r"""


    Get the number of children of a node in the scenegraph.  

    Parameters
    ----------
    * `aLabel` :  
        the label in the scenegraph  

    Returns
    -------
    the number of chidren  

    """
    return _gvxrPython3.getNumberOfChildren(aLabel)

def getChildLabel(aLabel, i):
    r"""


    Accessor on the i-th child's label in the list of children of a given node in
    the scenegraph.  

    Parameters
    ----------
    * `aLabel` :  
        the label in the scenegraph  
    * `i` :  
        the ID of the child  

    Returns
    -------
    the label corresponding to the i-th child  

    """
    return _gvxrPython3.getChildLabel(aLabel, i)

def getLocalTransformationMatrix(aLabel):
    r"""


    Accessor on the local transformation matrix of a given node in the scenegraph.
    If the node does not exist, the identity matrix is returned.  

    Parameters
    ----------
    * `aLabel` :  
        the label in the scenegraph  

    Returns
    -------
    the corresponding local transformation matrix  

    """
    return _gvxrPython3.getLocalTransformationMatrix(aLabel)

def setLocalTransformationMatrix(aLabel, aMatrix):
    r"""


    Set the local transformation matrix of a given node in the scenegraph.  

    Parameters
    ----------
    * `aLabel` :  
        the label in the scenegraph  
    * `aMatrix` :  
        the local transformation matrix  

    """
    return _gvxrPython3.setLocalTransformationMatrix(aLabel, aMatrix)

def applyCurrentLocalTransformation(aLabel):
    r"""


    Apply the current local transformation to all the vertices of a given node in
    the scenegraph. Note the the local transformation is then reset to the identity
    matrix.  

    Parameters
    ----------
    * `aLabel` :  
        the label in the scenegraph  

    """
    return _gvxrPython3.applyCurrentLocalTransformation(aLabel)

def getNodeAndChildrenBoundingBox(*args):
    r"""


    Access the bounding box of a given node and all its children (if any). The
    bounding box is given in the world coordinate system.  

    Parameters
    ----------
    * `aLabel` :  
        the label in the scenegraph  
    * `aUnitOfLength` :  
        the unit of length corresponding to the bounding box. Acceptable values are:
        "um", "micrometre", "micrometer", "mm", "millimetre",
        "millimeter", "cm", "centimetre", "centimeter", "dm",
        "decimetre", "decimeter", "m", "metre", "meter", "dam",
        "decametre", "decameter", "hm", "hectometre", "hectometer",
        "km", "kilometre", "kilometer" (default value: "cm")  

    Returns
    -------
    the bounding box as: min_x, min_y, min_z, max_x, max_y, max_z  

    """
    return _gvxrPython3.getNodeAndChildrenBoundingBox(*args)

def getNodeOnlyBoundingBox(*args):
    r"""


    Access the bounding box of a given node (without its children). The bounding box
    is given in the world coordinate system.  

    Parameters
    ----------
    * `aLabel` :  
        the label in the scenegraph  
    * `aUnitOfLength` :  
        the unit of length corresponding to the bounding box. Acceptable values are:
        "um", "micrometre", "micrometer", "mm", "millimetre",
        "millimeter", "cm", "centimetre", "centimeter", "dm",
        "decimetre", "decimeter", "m", "metre", "meter", "dam",
        "decametre", "decameter", "hm", "hectometre", "hectometer",
        "km", "kilometre", "kilometer" (default value: "cm")  

    Returns
    -------
    the bounding box as: min_x, min_y, min_z, max_x, max_y, max_z  

    """
    return _gvxrPython3.getNodeOnlyBoundingBox(*args)

def displayNode(aLabel):
    r"""


    Display the scenegraph node using OpenGL.  

    Parameters
    ----------
    * `aLabel` :  
        the label of the polygon mesh  

    """
    return _gvxrPython3.displayNode(aLabel)

def invertNormalVectors(aLabel):
    r"""


    Invert the normal vectors of a given polygon mesh.  

    Parameters
    ----------
    * `aLabel` :  
        the label of the polygon mesh  

    """
    return _gvxrPython3.invertNormalVectors(aLabel)

def setColor(aLabel, R, G, B, A):
    r"""


    Set the color of a given polygon mesh.  

    Parameters
    ----------
    * `aLabel` :  
        the label of the polygon mesh  
    * `R` :  
        the red channel  
    * `G` :  
        the green channel  
    * `B` :  
        the blue channel  
    * `A` :  
        the alpha channel  

    """
    return _gvxrPython3.setColor(aLabel, R, G, B, A)

def setColour(aLabel, R, G, B, A):
    r"""


    Set the colour of a given polygon mesh.  

    Parameters
    ----------
    * `aLabel` :  
        the label of the polygon mesh  
    * `R` :  
        the red channel  
    * `G` :  
        the green channel  
    * `B` :  
        the blue channel  
    * `A` :  
        the alpha channel  

    """
    return _gvxrPython3.setColour(aLabel, R, G, B, A)

def getAmbientColour(aLabel):
    r"""


    Accessor on the ambient colour of the material of a given polygon mesh.  

    Returns
    -------
    the ambient colour  

    """
    return _gvxrPython3.getAmbientColour(aLabel)

def getDiffuseColour(aLabel):
    r"""


    Accessor on the diffuse colour of the material of a given polygon mesh.  

    Returns
    -------
    the diffuse colour  

    """
    return _gvxrPython3.getDiffuseColour(aLabel)

def getSpecularColour(aLabel):
    r"""


    Accessor on the specular colour of the material of a given polygon mesh.  

    Returns
    -------
    the specular colour  

    """
    return _gvxrPython3.getSpecularColour(aLabel)

def getShininess(aLabel):
    r"""


    Accessor on the shininess of the material of a given polygon mesh.  

    Returns
    -------
    the shininess coefficient  

    """
    return _gvxrPython3.getShininess(aLabel)

def addPolygonMeshAsInnerSurface(aLabel):
    r"""


    Add a polygon mesh, given its label, to the X-ray renderer as an inner surface.  

    Parameters
    ----------
    * `aLabel` :  
        the label of the polygon mesh in the scenegraph  

    """
    return _gvxrPython3.addPolygonMeshAsInnerSurface(aLabel)

def addPolygonMeshAsOuterSurface(aLabel):
    r"""


    Add a polygon mesh, given its label, to the X-ray renderer as an outer surface.  

    Parameters
    ----------
    * `aLabel` :  
        the label of the polygon mesh in the scenegraph  

    """
    return _gvxrPython3.addPolygonMeshAsOuterSurface(aLabel)

def removePolygonMeshesFromSceneGraph():
    r"""


    Empty the scenegraph. Note that it also empties the X-ray renderer from all its
    meshes.  

    """
    return _gvxrPython3.removePolygonMeshesFromSceneGraph()

def removePolygonMeshesFromXRayRenderer():
    r"""


    Empty the X-ray renderer from all its meshes. Note that the meshes are kept in
    the scenegraph.  

    """
    return _gvxrPython3.removePolygonMeshesFromXRayRenderer()

def moveToCenter(*args):
    r"""


    Move a polygon mesh to the centre.  

    Parameters
    ----------
    * `aLabel` :  
        the label of the polygon mesh in the scenegraph  

    """
    return _gvxrPython3.moveToCenter(*args)

def moveToCentre(*args):
    r"""


    Move a polygon mesh to the centre.  

    Parameters
    ----------
    * `aLabel` :  
        the label of the polygon mesh in the scenegraph  

    """
    return _gvxrPython3.moveToCentre(*args)

def scaleNode(aLabel, x, y, z, aUnitOfLength):
    r"""


    Scale a polygon mesh.  

    Parameters
    ----------
    * `aLabel` :  
        the label of the polygon mesh to transform  
    * `x` :  
        the scaling factor along the X-axis  
    * `y` :  
        the scaling factor along the Y-axis  
    * `z` :  
        the scaling factor along the Z-axis  
    * `aUnitOfLength` :  
        the unit of length corresponding to the x, y and z parameters. Acceptable
        values are: "um", "micrometre", "micrometer", "mm", "millimetre",
        "millimeter", "cm", "centimetre", "centimeter", "dm",
        "decimetre", "decimeter", "m", "metre", "meter", "dam",
        "decametre", "decameter", "hm", "hectometre", "hectometer",
        "km", "kilometre", "kilometer"  

    """
    return _gvxrPython3.scaleNode(aLabel, x, y, z, aUnitOfLength)

def rotateNode(aLabel, anAngle, x, y, z):
    r"""


    Rotate a polygon mesh.  

    Parameters
    ----------
    * `aLabel` :  
        the label of the polygon mesh to transform  
    * `anAngle` :  
        the rotation angle in degrees  
    * `x` :  
        the component of the rotation vector along the X-axis  
    * `y` :  
        the component of the rotation vector along the Y-axis  
    * `z` :  
        the component of the rotation vector along the Z-axis  

    """
    return _gvxrPython3.rotateNode(aLabel, anAngle, x, y, z)

def translateNode(aLabel, x, y, z, aUnitOfLength):
    r"""


    Translate a polygon mesh.  

    Parameters
    ----------
    * `aLabel` :  
        the label of the polygon mesh to transform  
    * `x` :  
        the component of the translation vector along the X-axis  
    * `y` :  
        the component of the translation vector along the Y-axis  
    * `z` :  
        the component of the translation vector along the Z-axis  
    * `aUnitOfLength` :  
        the unit of length corresponding to the x, y and z parameters. Acceptable
        values are: "um", "micrometre", "micrometer", "mm", "millimetre",
        "millimeter", "cm", "centimetre", "centimeter", "dm",
        "decimetre", "decimeter", "m", "metre", "meter", "dam",
        "decametre", "decameter", "hm", "hectometre", "hectometer",
        "km", "kilometre", "kilometer"  

    """
    return _gvxrPython3.translateNode(aLabel, x, y, z, aUnitOfLength)

def shearNode(aLabel, yx, zx, xy, zy, xz, yz):
    r"""


    Use a shear matrix to transform the node.  

    Parameters
    ----------
    * `aLabel` :  
        the label of the polygon mesh to transform  
    * `yx` :  
        the yx component of the shear matrix  
    * `zx` :  
        the zx component of the shear matrix  
    * `xy` :  
        the xy component of the shear matrix  
    * `zy` :  
        the zy component of the shear matrix  
    * `xz` :  
        the xz component of the shear matrix  
    * `yz` :  
        the yz component of the shear matrix  

    """
    return _gvxrPython3.shearNode(aLabel, yx, zx, xy, zy, xz, yz)

def resetSceneTransformation():
    r"""


    Replace the 3-D transformation matrix of the overall 3-D scene by an identity
    matrix.  

    """
    return _gvxrPython3.resetSceneTransformation()

def scaleScene(*args):
    r"""


    Scale the 3-D scene (all the polygon meshes will be affected but not modified).  

    Parameters
    ----------
    * `x` :  
        the scaling factor along the X-axis  
    * `y` :  
        the scaling factor along the Y-axis  
    * `z` :  
        the scaling factor along the Z-axis  
    * `aUnitOfLength` :  
        the unit of length corresponding to the x, y and z parameters. Acceptable
        values are: "um", "micrometre", "micrometer", "mm", "millimetre",
        "millimeter", "cm", "centimetre", "centimeter", "dm",
        "decimetre", "decimeter", "m", "metre", "meter", "dam",
        "decametre", "decameter", "hm", "hectometre", "hectometer",
        "km", "kilometre", "kilometer"  

    """
    return _gvxrPython3.scaleScene(*args)

def rotateScene(anAngle, x, y, z):
    r"""


    Rotate the 3-D scene (all the polygon meshes will be affected but not modified).  

    Parameters
    ----------
    * `anAngle` :  
        the rotation angle in degrees  
    * `x` :  
        the component of the rotation vector along the X-axis  
    * `y` :  
        the component of the rotation vector along the Y-axis  
    * `z` :  
        the component of the rotation vector along the Z-axis  

    """
    return _gvxrPython3.rotateScene(anAngle, x, y, z)

def translateScene(x, y, z, aUnitOfLength):
    r"""


    Translate the 3-D scene (all the polygon meshes will be affected but not
    modified).  

    Parameters
    ----------
    * `x` :  
        the component of the translation vector along the X-axis  
    * `y` :  
        the component of the translation vector along the Y-axis  
    * `z` :  
        the component of the translation vector along the Z-axis  
    * `aUnitOfLength` :  
        the unit of length corresponding to the x, y and z parameters. Acceptable
        values are: "um", "micrometre", "micrometer", "mm", "millimetre",
        "millimeter", "cm", "centimetre", "centimeter", "dm",
        "decimetre", "decimeter", "m", "metre", "meter", "dam",
        "decametre", "decameter", "hm", "hectometre", "hectometer",
        "km", "kilometre", "kilometer"  

    """
    return _gvxrPython3.translateScene(x, y, z, aUnitOfLength)

def getSceneTransformationMatrix():
    r"""


    Accessor on the 3-D scene transformation matrix.  

    Returns
    -------
    the 3-D scene transformation matrix as a 4x4 array  

    """
    return _gvxrPython3.getSceneTransformationMatrix()

def getRootTransformationMatrix():
    r"""


    Accessor on the transformation matrix of the scengraph's root node.  

    Returns
    -------
    the scengraph's root node transformation matrix as a 4x4 array  

    """
    return _gvxrPython3.getRootTransformationMatrix()

def getNodeTransformationMatrix(aLabel):
    r"""


    Accessor on the transformation matrix of a given node.  

    Parameters
    ----------
    * `aLabel` :  
        the label of the polygon mesh  

    Returns
    -------
    the scengraph's root node transformation matrix as a 4x4 array  

    """
    return _gvxrPython3.getNodeTransformationMatrix(aLabel)

def setSceneTransformationMatrix(aMatrix):
    r"""


    Set the 3-D scene transformation matrix.  

    Parameters
    ----------
    * `aMatrix` :  
        the transformation matrix as a 4x4 array  

    """
    return _gvxrPython3.setSceneTransformationMatrix(aMatrix)

def setRootTransformationMatrix(aMatrix):
    r"""


    Set the transformation matrix of the scengraph's root node.  

    Parameters
    ----------
    * `aMatrix` :  
        the transformation matrix as a 4x4 array  

    """
    return _gvxrPython3.setRootTransformationMatrix(aMatrix)

def setNodeTransformationMatrix(aLabel, aMatrix):
    r"""


    Set the transformation matrix of a given node.  

    Parameters
    ----------
    * `aLabel` :  
        the label of the polygon mesh  
    * `aMatrix` :  
        the transformation matrix as a 4x4 array  

    """
    return _gvxrPython3.setNodeTransformationMatrix(aLabel, aMatrix)

def setHU(aLabel, HU):
    r"""


    Set the Hounsfield value corresponding to the material properties of a polygon
    mesh.  

    Parameters
    ----------
    * `aLabel` :  
        the label of the polygon mesh  
    * `HU` :  
        the Hounsfield value  

    """
    return _gvxrPython3.setHU(aLabel, HU)

def setHounsfieldUnit(aLabel, HU):
    r"""


    Set the Hounsfield value corresponding to the material properties of a polygon
    mesh.  

    Parameters
    ----------
    * `aLabel` :  
        the label of the polygon mesh  
    * `HU` :  
        the Hounsfield value  

    """
    return _gvxrPython3.setHounsfieldUnit(aLabel, HU)

def setHounsfieldValue(aLabel, HU):
    r"""


    Set the Hounsfield value corresponding to the material properties of a polygon
    mesh.  

    Parameters
    ----------
    * `aLabel` :  
        the label of the polygon mesh  
    * `HU` :  
        the Hounsfield value  

    """
    return _gvxrPython3.setHounsfieldValue(aLabel, HU)

def setElement(*args):
    r"""


    Set the chemical element (or element) corresponding to the material properties
    of a polygon mesh.  

    Parameters
    ----------
    * `aLabel` :  
        the label of the polygon mesh  
    * `aName` :  
        the symbol or name corresponding to the element  

    """
    return _gvxrPython3.setElement(*args)

def setMixture(aLabel, aMixture):
    r"""


    Set the mixture corresponding to the material properties of a polygon mesh.
    Don't forget to set the density of the material.  

    Parameters
    ----------
    * `aLabel` :  
        the label of the polygon mesh  
    * `aMixture` :  
        the details about the mixture. It is given as a sequence of element symbol &
        relative weight, e.g. Ti90Al6V4.  

    """
    return _gvxrPython3.setMixture(aLabel, aMixture)

def setCompound(aLabel, aCompound):
    r"""


    Set the compound corresponding to the material properties of a polygon mesh.
    Don't forget to set the density of the material.  

    Parameters
    ----------
    * `aLabel` :  
        the label of the polygon mesh  
    * `aCompound` :  
        the details about the compound. It is given as a sequence of element symbol
        & number of atoms, e.g. H2O for water and SiC for silicon carbide.  

    """
    return _gvxrPython3.setCompound(aLabel, aCompound)

def setMassAttenuationCoefficient(aLabel, aCoefficient, aUnit):
    r"""


    Set the mass attenuation coefficient corresponding to the material properties of
    a polygon mesh. Don't forget to set the density of the material.  

    Parameters
    ----------
    * `aLabel` :  
        the label of the polygon mesh  
    * `aCoefficient` :  
        the mass attenuation coefficient  
    * `aUnit` :  
        the unit corresponding to aCoefficient. Acceptable values are: "cm2/g" and
        "cm2.g-1"  

    """
    return _gvxrPython3.setMassAttenuationCoefficient(aLabel, aCoefficient, aUnit)

def setLinearAttenuationCoefficient(aLabel, aCoefficient, aUnit):
    r"""


    Set the linear attenuation coefficient corresponding to the material properties
    of a polygon mesh.  

    Parameters
    ----------
    * `aLabel` :  
        the label of the polygon mesh  
    * `aCoefficient` :  
        the liner attenuation coefficient  
    * `aUnit` :  
        the unit corresponding to aCoefficient. Acceptable values are: "cm-1"  

    """
    return _gvxrPython3.setLinearAttenuationCoefficient(aLabel, aCoefficient, aUnit)

def setMu(aLabel, aCoefficient, aUnit):
    r"""


    Set the linear attenuation coefficient corresponding to the material properties
    of a polygon mesh.  

    Parameters
    ----------
    * `aLabel` :  
        the label of the polygon mesh  
    * `aCoefficient` :  
        the liner attenuation coefficient  
    * `aUnit` :  
        the unit corresponding to aCoefficient. Acceptable values are: "cm-1"  

    """
    return _gvxrPython3.setMu(aLabel, aCoefficient, aUnit)

def setDensity(aLabel, aDensity, aUnit):
    r"""


    Set the density corresponding to the material properties of a polygon mesh.  

    Parameters
    ----------
    * `aLabel` :  
        the label of the polygon mesh  
    * `aDensity` :  
        the density  
    * `aUnit` :  
        the unit corresponding to aDensity. Acceptable values are: "g/cm3" and
        "g.cm-3"  

    """
    return _gvxrPython3.setDensity(aLabel, aDensity, aUnit)

def getDensity(aLabel):
    r"""


    Accessor on the density corresponding to the material properties of a polygon
    mesh.  

    Parameters
    ----------
    * `aLabel` :  
        the label of the polygon mesh  

    Returns
    -------
    the density of the polygon mesh's material in g/cm3  

    """
    return _gvxrPython3.getDensity(aLabel)

def getMassAttenuationCoefficient(aLabel, anEnergy, aUnitOfEnergy):
    r"""


    Accessor on the mass attenuation coefficient at a given energy corresponding to
    the material properties of a polygon mesh.  

    Parameters
    ----------
    * `aLabel` :  
        the label of the polygon mesh  
    * `anEnergy` :  
        the photon energy of interest  
    * `aUnitOfEnergy` :  
        the unit of energy corresponding to anEnergy. Acceptable values are:
        "electronvolt", "eV", "kiloelectronvolt", "keV",
        "megaelectronvolt", "MeV"  

    Returns
    -------
    the mass attenuation coefficient of the polygon mesh's material in cm2/g  

    """
    return _gvxrPython3.getMassAttenuationCoefficient(aLabel, anEnergy, aUnitOfEnergy)

def getLinearAttenuationCoefficient(aLabel, anEnergy, aUnitOfEnergy):
    r"""


    Accessor on the linear attenuation coefficient at a given energy corresponding
    to the material properties of a polygon mesh.  

    Parameters
    ----------
    * `aLabel` :  
        the label of the polygon mesh  
    * `anEnergy` :  
        the photon energy of interest  
    * `aUnitOfEnergy` :  
        the unit of energy corresponding to anEnergy. Acceptable values are:
        "electronvolt", "eV", "kiloelectronvolt", "keV",
        "megaelectronvolt", "MeV"  

    Returns
    -------
    the linear attenuation coefficient of the polygon mesh's material in cm-1  

    """
    return _gvxrPython3.getLinearAttenuationCoefficient(aLabel, anEnergy, aUnitOfEnergy)

def getMaterialLabel(aLabel):
    r"""


    Accessor on the material label of a polygon mesh.  

    Parameters
    ----------
    * `aLabel` :  
        the label of the polygon mesh  

    Returns
    -------
    the label of the material  

    """
    return _gvxrPython3.getMaterialLabel(aLabel)

def createOpenGLContext(aWindowID=-1, aRendererMajorVersion=3, aRendererMinorVersion=2):
    r"""


    Create an OpenGL context (the window won't be shown).  

    Parameters
    ----------
    * `aWindowID` :  
        the numerical ID of the context to create (default value: -1, means that the
        ID will be automatically generated)  

    """
    return _gvxrPython3.createOpenGLContext(aWindowID, aRendererMajorVersion, aRendererMinorVersion)

def createWindow(*args):
    r"""


    Create an OpenGL context and display it in a window.  

    Parameters
    ----------
    * `aWindowID` :  
        the numerical ID of the context to create (default value: -1, means that the
        ID will be automatically generated)  
    * `aVisibilityFlag` :  
        flag controling if the window should be visible (1) or hidden (0). (default
        value: 0)  

    """
    return _gvxrPython3.createWindow(*args)

def setWindowSize(aWidth, aHeight, aWindowID=-1):
    r"""


    Create an OpenGL context and display it in a window.  

    Parameters
    ----------
    * `aWidth` :  
        the number of pixels along the X-axis  
    * `aHeight` :  
        the number of pixels along the Y-axis  
    * `aWindowID` :  
        the numerical ID of the corresponding context (default value: -1, means that
        the active context will be used)  

    """
    return _gvxrPython3.setWindowSize(aWidth, aHeight, aWindowID)

def displayScene(aSceneRotationFlag=True, aWindowID=-1):
    r"""


    3-D visualisation of the 3-D scene (source, detector, and scanned objects). Note
    that there is no interactive loop running.  

    Parameters
    ----------
    * `aSceneRotationFlag` :  
        true if the 3-D scene has to be rotated with the arc-ball method, false
        otherwise (default value: true)  
    * `aWindowID` :  
        the numerical ID of the corresponding context (default value: -1, means that
        the active context will be used)  

    """
    return _gvxrPython3.displayScene(aSceneRotationFlag, aWindowID)

def renderLoop(aWindowID=-1):
    r"""


    3-D visualisation of the 3-D scene (source, detector, and scanned objects). Note
    that there is interactive loop running. Keys are:  

    *   Q/Escape: to quit the event loop (does not close the window)  
    *   B: display/hide the X-ray beam  
    *   W: display the polygon meshes in solid or wireframe  
    *   N: display the X-ray image in negative or positive  
    *   L: switch lighting on/off  
    *   D: display/hide the X-ray detector  
    *   V: display/hide normal vectors  

        Parameters:  
        * `aWindowID` :  
            the numerical ID of the corresponding context (default value: -1, means
            that the active context will be used)  

    """
    return _gvxrPython3.renderLoop(aWindowID)

def startArcBallRotation(x, y):
    r"""


    Call this function when the user starts an arc-ball rotation (e.g. left-mouse
    button click in the 3-D visualisation window).  

    Parameters
    ----------
    * `x` :  
        the cursor x-axis position in the viewport coordinate system  
    * `y` :  
        the cursor y-axis position in the viewport coordinate system  

    """
    return _gvxrPython3.startArcBallRotation(x, y)

def stopArcBallRotation():
    r"""


    Call this function when the user stops an arc-ball rotation (e.g. release the
    left-mouse button click in the 3-D visualisation window).  

    """
    return _gvxrPython3.stopArcBallRotation()

def usingArcBallRotation():
    r"""


    Check if arc-ball rotation is currently in use.  

    Returns
    -------
    true if arc-ball rotation is currently in use, false otherwise  

    """
    return _gvxrPython3.usingArcBallRotation()

def cursorPositionCallback(x, y, aViewportWidth, aViewportHeight):
    r"""


    Call this function when the user moves the mouse.  

    Parameters
    ----------
    * `x` :  
        the cursor x-axis position in the viewport coordinate system  
    * `y` :  
        the cursor y-axis position in the viewport coordinate system  
    * `aViewportWidth` :  
        the size of the viewport along the x-axis  
    * `aViewportHeight` :  
        the size of the viewport along the y-axis  

    """
    return _gvxrPython3.cursorPositionCallback(x, y, aViewportWidth, aViewportHeight)

def scrollCallback(xoffset, yoffset):
    r"""


    Call this function when the user scrolls.  

    Parameters
    ----------
    * `xoffset` :  
        the scroll offset along the x-axis (not used)  
    * `yoffset` :  
        the scroll offset along the y-axis (used for zooming in and out)  

    """
    return _gvxrPython3.scrollCallback(xoffset, yoffset)

def showWindow(aWindowID=-1):
    r"""


    Make an OpenGL context visible and display a window.  

    Parameters
    ----------
    * `aWindowID` :  
        the numerical ID of the corresponding context (default value: -1, means that
        the active context will be used)  

    """
    return _gvxrPython3.showWindow(aWindowID)

def hideWindow(aWindowID=-1):
    r"""


    Hide a window.  

    Parameters
    ----------
    * `aWindowID` :  
        the numerical ID of the corresponding context (default value: -1, means that
        the active context will be used)  

    """
    return _gvxrPython3.hideWindow(aWindowID)

def destroyWindow(aWindowID=-1):
    r"""


    Close and destroy a given window or OpenGL context.  

    """
    return _gvxrPython3.destroyWindow(aWindowID)

def destroyAllWindows():
    r"""


    Close and destroy all the windows and OpenGL contexts that have been created.  

    """
    return _gvxrPython3.destroyAllWindows()

def usePointSource():
    r"""


    Use a point source.  

    """
    return _gvxrPython3.usePointSource()

def useParallelBeam():
    r"""


    Use a parallel source (e.g. to mimic a source that is extremely far from the
    scanned object and detector).  

    """
    return _gvxrPython3.useParallelBeam()

def useParallelSource():
    r"""


    Use a parallel source (e.g. to mimic a source that is extremely far from the
    scanned object and detector).  

    """
    return _gvxrPython3.useParallelSource()

def resetBeamSpectrum():
    r"""


    Empty the beam spectrum.  

    """
    return _gvxrPython3.resetBeamSpectrum()

def setMonoChromatic(anEnergy, aUnitOfEnergy, aNumberOfPhotons):
    r"""


    Use a monochromatic beam spectrum (i.e. one single energy).  

    Parameters
    ----------
    * `anEnergy` :  
        the incident photon energy  
    * `aUnitOfEnergy` :  
        the unit of energy corresponding to anEnergy. Acceptable values are:
        "electronvolt", "eV", "kiloelectronvolt", "keV",
        "megaelectronvolt", "MeV"  
    * `aNumberOfPhotons` :  
        the number of incident photons  

    """
    return _gvxrPython3.setMonoChromatic(anEnergy, aUnitOfEnergy, aNumberOfPhotons)

def addEnergyBinToSpectrum(anEnergy, aUnitOfEnergy, aNumberOfPhotons):
    r"""


    Add an energy bin to the beam spectrum (useful to generate polychromatism).  

    Parameters
    ----------
    * `anEnergy` :  
        the incident photon energy  
    * `aUnitOfEnergy` :  
        the unit of energy corresponding to anEnergy. Acceptable values are:
        "electronvolt", "eV", "kiloelectronvolt", "keV",
        "megaelectronvolt", "MeV"  
    * `aNumberOfPhotons` :  
        the number of incident photons  

    """
    return _gvxrPython3.addEnergyBinToSpectrum(anEnergy, aUnitOfEnergy, aNumberOfPhotons)

def loadSpectrumFromTSV(aFileName, aUnitOfEnergy, aNormalisationFlag):
    r"""


    Load the incident beam energy spectrum from a TSV file.  

    Parameters
    ----------
    * `aFileName` :  
        name of the file to load  
    * `aUnitOfEnergy` :  
        the unit of energy corresponding to anEnergy. Acceptable values are:
        "electronvolt", "eV", "kiloelectronvolt", "keV",
        "megaelectronvolt", "MeV"  
    * `aNormalisationFlag` :  
        true to normalise the total energy to 1, false otherwise  

    """
    return _gvxrPython3.loadSpectrumFromTSV(aFileName, aUnitOfEnergy, aNormalisationFlag)

def getEnergyBins(aUnitOfEnergy):
    r"""


    Accessor on the energy bins of the beam spectrum.  

    Parameters
    ----------
    * `aUnitOfEnergy` :  
        the unit of energy corresponding to the returned vector. Acceptable values
        are: "electronvolt", "eV", "kiloelectronvolt", "keV",
        "megaelectronvolt", "MeV"  

    Returns
    -------
    the list of energy bins in aUnitOfEnergy  

    """
    return _gvxrPython3.getEnergyBins(aUnitOfEnergy)

def getPhotonCountEnergyBins():
    r"""


    Accessor on the number of photons per energy bin of the beam spectrum.  

    Returns
    -------
    the list of number of photons  

    """
    return _gvxrPython3.getPhotonCountEnergyBins()

def saveSTLfile(*args):
    r"""


    Save the polygon mesh of a given node.  

    Parameters
    ----------
    * `aLabel` :  
        the label of the polygon mesh  
    * `aFileName` :  
        the name of the output file (default: means that the filename will be
        automatically generated and the file saved in the current path)  

    """
    return _gvxrPython3.saveSTLfile(*args)

def saveLastXRayImage(*args):
    r"""


    Save the last X-ray image that has been computed.  

    Parameters
    ----------
    * `aFileName` :  
        the name of the output file (default: means that the filename will be
        automatically generated and the file saved in the current path)  
    * `useCompression` :  
        use data compression is possible (default: true)  

    """
    return _gvxrPython3.saveLastXRayImage(*args)

def saveLastLBuffer(*args):
    r"""


    Save the last L-buffer that has been computed.  

    Parameters
    ----------
    * `aFileName` :  
        the name of the output file (default: means that the filename will be
        automatically generated and the file saved in the current path)  
    * `useCompression` :  
        use data compression is possible (default: true)  

    """
    return _gvxrPython3.saveLastLBuffer(*args)

def saveLastCumulatedLBuffer(*args):
    r"""


    Save the last cumulated L-buffer that has been computed.  

    Parameters
    ----------
    * `aFileName` :  
        the name of the output file (default: means that the filename will be
        automatically generated and the file saved in the current path)  
    * `useCompression` :  
        use data compression is possible (default: true)  

    """
    return _gvxrPython3.saveLastCumulatedLBuffer(*args)

def saveLastSinogram(*args):
    r"""


    Save the last sinogram that has been computed.  

    Parameters
    ----------
    * `aFileName` :  
        the name of the output file (default: 0 means that the filename will be
        automatically generated and the file saved in the current path)  
    * `useCompression` :  
        use data compression is possible (default: true)  

    """
    return _gvxrPython3.saveLastSinogram(*args)

def saveLastProjectionSet(*args):
    r"""


    Save the last projection set that has been computed.  

    Parameters
    ----------
    * `aFileName` :  
        the name of the output file (default: 0 means that the filename will be
        automatically generated and the file saved in the current path)  
    * `useCompression` :  
        use data compression is possible (default: true)  

    """
    return _gvxrPython3.saveLastProjectionSet(*args)

def enableArtefactFilteringOnGPU():
    r"""


    Enable artefact filtering on GPU (it is fast but can be inaccurate).  

    """
    return _gvxrPython3.enableArtefactFilteringOnGPU()

def enableArtifactFilteringOnGPU():
    r"""


    Enable artefact filtering on GPU (it is fast but can be inaccurate).  

    """
    return _gvxrPython3.enableArtifactFilteringOnGPU()

def enableArtefactFilteringOnCPU():
    r"""


    Enable artefact filtering on CPU (can be extremely slow as it makes use of ray-
    tracing).  

    """
    return _gvxrPython3.enableArtefactFilteringOnCPU()

def enableArtifactFilteringOnCPU():
    r"""


    Enable artefact filtering on CPU (can be extremely slow as it makes use of ray-
    tracing).  

    """
    return _gvxrPython3.enableArtifactFilteringOnCPU()

def disableArtefactFiltering():
    r"""


    Disable artefact filtering altogether.  

    """
    return _gvxrPython3.disableArtefactFiltering()

def disableArtifactFiltering():
    r"""


    Disable artefact filtering altogether.  

    """
    return _gvxrPython3.disableArtifactFiltering()

def getUnitOfEnergy(aUnitOfEnergy):
    r"""


    Accessor on the numerical value corresponding to a unit of energy.  

    Parameters
    ----------
    * `aUnitOfEnergy` :  
        the unit of energy. Acceptable values are: "electronvolt", "eV",
        "kiloelectronvolt", "keV", "megaelectronvolt", "MeV"  

    Returns
    -------
    the corresponding numerical value  

    """
    return _gvxrPython3.getUnitOfEnergy(aUnitOfEnergy)

def getUnitOfLength(aUnitOfLength):
    r"""


    Accessor on the numerical value corresponding to a unit of length.  

    Parameters
    ----------
    * `aUnitOfLength` :  
        the unit of length. Acceptable values are: "um", "micrometre",
        "micrometer", "mm", "millimetre", "millimeter", "cm",
        "centimetre", "centimeter", "dm", "decimetre", "decimeter", "m",
        "metre", "meter", "dam", "decametre", "decameter", "hm",
        "hectometre", "hectometer", "km", "kilometre", "kilometer"  

    Returns
    -------
    the corresponding numerical value  

    """
    return _gvxrPython3.getUnitOfLength(aUnitOfLength)

def computeXRayImage():
    r"""


    Compute the X-ray projection corresponding to the environment that has
    previously been set, i.e.  

    *   Detector position  
    *   Detector orientation  
    *   Detector size and resolution  
    *   Source position  
    *   Source shape  
    *   Beam spectrum  
    *   Scanned object geometries  
    *   Scanned object material properties  

        Returns:
        the corresponding X-ray image  

    """
    return _gvxrPython3.computeXRayImage()

def computeLBuffer(aLabel):
    r"""


    Compute the L-buffer of a polygon mesh corresponding to the environment that has
    previously been set, i.e.  

    *   Detector position  
    *   Detector orientation  
    *   Detector size and resolution  
    *   Source position  
    *   Source shape  
    *   Scanned object geometry  

        Parameters:  
        * `aLabel` :  
            the label of the polygon mesh  

        Returns:
        the corresponding L-buffer  

    """
    return _gvxrPython3.computeLBuffer(aLabel)

def computeSinogram(x, y, z, aUnitOfLength, aNumberOfAngle, anAngleOffset):
    r"""


    Compute the sinogram corresponding to the environment that has previously been
    set, i.e.  

    *   Detector position  
    *   Detector orientation  
    *   Detector size and resolution  
    *   Source position  
    *   Source shape  
    *   Beam spectrum  
    *   Scanned object geometries  
    *   Scanned object material properties Note that the rotation vector is the same
        as the up-vector of the detector.  

        Parameters:  
        * `x` :  
            the position of the rotation centre along the X-axis  
        * `y` :  
            the position of the rotation centre along the Y-axis  
        * `z` :  
            the position of the rotation centre along the Z-axis  
        * `aUnitOfLength` :  
            the unit of length corresponding to the x, y and z parameters.
            Acceptable values are: "um", "micrometre", "micrometer", "mm",
            "millimetre", "millimeter", "cm", "centimetre", "centimeter",
            "dm", "decimetre", "decimeter", "m", "metre", "meter",
            "dam", "decametre", "decameter", "hm", "hectometre",
            "hectometer", "km", "kilometre", "kilometer"  
        * `aNumberOfAngle` :  
            the total number of projections in the sinogram  
        * `anAngleOffset` :  
            the angle in degrees between two successive projections  

        Returns:
        the corresponding sinogram  

    """
    return _gvxrPython3.computeSinogram(x, y, z, aUnitOfLength, aNumberOfAngle, anAngleOffset)

def computeProjectionSet(x, y, z, aUnitOfLength, aNumberOfAngle, anAngleOffset):
    r"""


    Compute the projection set corresponding to the environment that has previously
    been set, i.e.  

    *   Detector position  
    *   Detector orientation  
    *   Detector size and resolution  
    *   Source position  
    *   Source shape  
    *   Beam spectrum  
    *   Scanned object geometries  
    *   Scanned object material properties Note that the rotation vector is the same
        as the up-vector of the detector.  

        Parameters:  
        * `x` :  
            the position of the rotation centre along the X-axis  
        * `y` :  
            the position of the rotation centre along the Y-axis  
        * `z` :  
            the position of the rotation centre along the Z-axis  
        * `aUnitOfLength` :  
            the unit of length corresponding to the x, y and z parameters.
            Acceptable values are: "um", "micrometre", "micrometer", "mm",
            "millimetre", "millimeter", "cm", "centimetre", "centimeter",
            "dm", "decimetre", "decimeter", "m", "metre", "meter",
            "dam", "decametre", "decameter", "hm", "hectometre",
            "hectometer", "km", "kilometre", "kilometer"  
        * `aNumberOfAngle` :  
            the total number of projections in the projection set  
        * `anAngleOffset` :  
            the angle in degrees between two successive projections  

        Returns:
        the corresponding projection set  

    """
    return _gvxrPython3.computeProjectionSet(x, y, z, aUnitOfLength, aNumberOfAngle, anAngleOffset)

def getLastXRayImage():
    r"""


    Accessor on the last X-ray image that has been computed.  

    Returns
    -------
    the last X-ray image  

    """
    return _gvxrPython3.getLastXRayImage()

def getLastLBuffer():
    r"""


    Accessor on the last L-buffer that has been computed.  

    Returns
    -------
    the last L-buffer  

    """
    return _gvxrPython3.getLastLBuffer()

def getLastSinogram():
    r"""


    Accessor on the last sinogram that has been computed.  

    Returns
    -------
    the last sinogram  

    """
    return _gvxrPython3.getLastSinogram()

def getLastProjectionSet():
    r"""


    Accessor on the last projection set that has been computed.  

    Returns
    -------
    the last projection set  

    """
    return _gvxrPython3.getLastProjectionSet()

def getImageWidth(anImage):
    r"""


    Accessor on the width of a given image.  

    Parameters
    ----------
    * `anImage` :  
        the image  

    Returns
    -------
    the width of the image (in number of pixels)  

    """
    return _gvxrPython3.getImageWidth(anImage)

def getImageHeght(anImage):
    r"""


    Accessor on the height of a given image.  

    Parameters
    ----------
    * `anImage` :  
        the image  

    Returns
    -------
    the height of the image (in number of pixels)  

    """
    return _gvxrPython3.getImageHeght(anImage)

def getImageRow(anImage, j):
    r"""


    Accessor on the j-th row of pixels of a given image.  

    Parameters
    ----------
    * `anImage` :  
        the image  
    * `j` :  
        the row number  

    Returns
    -------
    the j-th row of pixels  

    """
    return _gvxrPython3.getImageRow(anImage, j)

def getElementName(Z):
    r"""


    Accessor on the chemical element's name depending on its Z number.  

    Parameters
    ----------
    * `Z` :  
        the atomic number of the element  

    Returns
    -------
    the name of the corresponding element  

    """
    return _gvxrPython3.getElementName(Z)

def getElementSymbol(Z):
    r"""


    Accessor on the chemical element' symbol depending on its Z number.  

    Parameters
    ----------
    * `Z` :  
        the atomic number of the element  

    Returns
    -------
    the name of the corresponding element  

    """
    return _gvxrPython3.getElementSymbol(Z)

def getElementAtomicNumber(anElement):
    r"""


    Accessor on the chemical element's Z number.  

    Parameters
    ----------
    * `anElement` :  
        the name or symbol of the element  

    Returns
    -------
    the Z number of the corresponding element  

    """
    return _gvxrPython3.getElementAtomicNumber(anElement)

def getDensityFromElement(*args):
    r"""


    Accessor on the chemical element's density.  

    Parameters
    ----------
    * `Z` :  
        the Z number of the element  

    Returns
    -------
    the density of the corresponding element (in g / cm3)  

    """
    return _gvxrPython3.getDensityFromElement(*args)

def getDensityFromHU(HU):
    r"""


    Accessor on the HU's density.  

    Parameters
    ----------
    * `HU` :  
        the HU  

    Returns
    -------
    the density of the corresponding HU (in g / cm3)  

    """
    return _gvxrPython3.getDensityFromHU(HU)

def getMassAttenuationFromElement(*args):
    r"""


    Accessor on the chemical element's mass attenuation.  

    Parameters
    ----------
    * `Z` :  
        the Z number of the element  
    * `anEnergy` :  
        the photon energy of interest  
    * `aUnitOfEnergy` :  
        the unit of energy corresponding to anEnergy. Acceptable values are:
        "electronvolt", "eV", "kiloelectronvolt", "keV",
        "megaelectronvolt", "MeV"  

    Returns
    -------
    the mass attenuation of the corresponding element (in cm2/g)  

    """
    return _gvxrPython3.getMassAttenuationFromElement(*args)

def getMassAttenuationFromHU(HU, anEnergy, aUnitOfEnergy):
    r"""


    Accessor on the HU's mass attenuation.  

    Parameters
    ----------
    * `HU` :  
        the HU  
    * `anEnergy` :  
        the photon energy of interest  
    * `aUnitOfEnergy` :  
        the unit of energy corresponding to anEnergy. Acceptable values are:
        "electronvolt", "eV", "kiloelectronvolt", "keV",
        "megaelectronvolt", "MeV"  

    Returns
    -------
    the density of the corresponding HU (in cm2/g)  

    """
    return _gvxrPython3.getMassAttenuationFromHU(HU, anEnergy, aUnitOfEnergy)

def getMassAttenuationFromMixture(aMixture, anEnergy, aUnitOfEnergy):
    r"""


    Accessor on the mixture's mass attenuation.  

    Parameters
    ----------
    * `aMixture` :  
        the details about the mixture. It is given as a sequence of element symbol &
        relative weight, e.g. Ti90Al6V4.  
    * `anEnergy` :  
        the photon energy of interest  
    * `aUnitOfEnergy` :  
        the unit of energy corresponding to anEnergy. Acceptable values are:
        "electronvolt", "eV", "kiloelectronvolt", "keV",
        "megaelectronvolt", "MeV"  

    Returns
    -------
    the mass attenuation of the corresponding mixture (in cm2/g)  

    """
    return _gvxrPython3.getMassAttenuationFromMixture(aMixture, anEnergy, aUnitOfEnergy)

def getMassAttenuationFromCompound(aCompound, anEnergy, aUnitOfEnergy):
    r"""


    Accessor on the compound's mass attenuation.  

    Parameters
    ----------
    * `aCompound` :  
        the details about the compound. It is given as a sequence of element symbol
        & number of atoms, e.g. H2O for water and SiC for silicon carbide.  
    * `anEnergy` :  
        the photon energy of interest  
    * `aUnitOfEnergy` :  
        the unit of energy corresponding to anEnergy. Acceptable values are:
        "electronvolt", "eV", "kiloelectronvolt", "keV",
        "megaelectronvolt", "MeV"  

    Returns
    -------
    the mass attenuation of the corresponding compound (in cm2/g)  

    """
    return _gvxrPython3.getMassAttenuationFromCompound(aCompound, anEnergy, aUnitOfEnergy)

def getMuFromHU(HU, anEnergy, aUnitOfEnergy):
    r"""


    Accessor on the HU's linear attenuation coefficient.  

    Parameters
    ----------
    * `HU` :  
        the HU  
    * `anEnergy` :  
        the photon energy of interest  
    * `aUnitOfEnergy` :  
        the unit of energy corresponding to anEnergy. Acceptable values are:
        "electronvolt", "eV", "kiloelectronvolt", "keV",
        "megaelectronvolt", "MeV"  

    Returns
    -------
    the linear attenuation coefficient (in cm-1)  

    """
    return _gvxrPython3.getMuFromHU(HU, anEnergy, aUnitOfEnergy)

def loadImage2D(aFileName):
    r"""


    void setShiftFilter(double aValue); void setScaleFilter(double aValue); double
    getShiftFilter(); double getScaleFilter();  

    """
    return _gvxrPython3.loadImage2D(aFileName)

def loadImage3D(aFileName):
    r"""


    """
    return _gvxrPython3.loadImage3D(aFileName)

def computeZNCC(aReferenceImage, aTestImage):
    r"""


    """
    return _gvxrPython3.computeZNCC(aReferenceImage, aTestImage)

def computeRMSE(aReferenceImage, aTestImage):
    r"""


    """
    return _gvxrPython3.computeRMSE(aReferenceImage, aTestImage)

def getMinValue(aImage):
    r"""


    """
    return _gvxrPython3.getMinValue(aImage)

def getMaxValue(aImage):
    r"""


    """
    return _gvxrPython3.getMaxValue(aImage)


